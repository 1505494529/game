<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>疯狂图片转盘 (约瑟夫环)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --player-diameter: 65px; /* Define player size for consistency */
        }

        body {
            font-family: 'Nunito', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #6dd5ed, #2193b0);
            margin: 0;
            text-align: center;
            color: #333;
            padding-top: 20px; /* Add some space at the top */
            padding-bottom: 20px;
        }

        .container h1 {
            font-family: 'Luckiest Guy', cursive;
            font-size: 3.2em; /* Slightly reduced for balance */
            color: #ff6347;
            text-shadow: 1px 1px 0px #fff,
                         2px 2px 0px #444,
                         3px 3px 0px rgba(255, 99, 71, 0.5);
            margin-bottom: 25px;
            letter-spacing: 2px;
        }

        .container {
            background-color: rgba(255, 255, 255, 0.92); /* Slightly more opaque */
            padding: 20px 25px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.25);
            width: 95vw;
            max-width: 1300px; /* Increased max-width */
        }

        .game-layout {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 25px;
        }

        .game-panel-left {
            flex: 1;
            max-width: 300px; /* Slightly increased */
            display: flex;
            flex-direction: column;
            gap: 18px;
            background-color: rgba(255, 255, 255, 0.75);
            padding: 18px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }

        .game-panel-right {
            flex: 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 0; /* Prevents flex item from overflowing */
        }

        .controls div {
            margin-bottom: 12px;
        }

        .controls label {
            display: block;
            width: calc(100% - 16px);
            margin-bottom: 6px;
            font-weight: 700;
            color: #555;
        }
        .controls input[type="number"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .controls button {
            width: 100%;
            padding: 12px 15px;
            background-color: #ff6347;
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .controls button:not(:disabled):hover {
            background-color: #e55337;
        }
        .controls button:not(:disabled):active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .simulation-mode-label {
            font-weight: 700;
            color: #555;
            margin-bottom: 8px;
            display: block;
        }
        .simulation-mode-options label {
            display: inline-block;
            margin-right: 15px;
            font-weight: normal;
            color: #444;
        }
        .simulation-mode-options input[type="radio"] {
            margin-right: 5px;
            vertical-align: middle;
        }

        .game-info {
            width: 100%;
            background-color: rgba(0,0,0, 0.05);
            padding: 15px;
            border-radius: 8px;
            box-sizing: border-box;
        }
        .game-info p {
            margin: 8px 0;
            font-size: 0.95em;
            color: #444;
            word-wrap: break-word;
            overflow-wrap: break-word;
            text-align: left;
            display: flex;
            align-items: center;
        }
        .game-info span {
            font-weight: 700;
            color: #2193b0;
            margin-left: 5px;
        }
        .game-info img.info-pic {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            margin-left: 5px;
            vertical-align: middle;
            border: 1px solid #ddd;
        }

        .circle-container {
            width: 550px; /* Increased size */
            height: 550px; /* Increased size */
            border: 4px dashed #ff6347; /* Slightly thicker border */
            border-radius: 50%;
            position: relative;
            margin: 20px auto;
            display: flex; /* Keep for potential future content, not strictly needed for abs positioned children */
            justify-content: center;
            align-items: center;
            background-color: rgba(255,255,255,0.45);
        }

        .player-image-container {
            position: absolute;
            transition: transform 0.3s ease-out, opacity 0.5s ease, left 0.5s ease-out, top 0.5s ease-out;
            width: var(--player-diameter);
            height: var(--player-diameter);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            overflow: hidden;
            background-color: #e0e0e0; /* Lighter fallback */
            box-shadow: 0 2px 4px rgba(0,0,0,0.15); /* Subtle shadow for depth */
        }
        .player-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .player-image-container.next-start {
            outline: 5px solid gold; /* Thicker outline */
            outline-offset: 3px;
            box-shadow: 0 0 18px gold, 0 0 8px rgba(0,0,0,0.3); /* Enhanced glow */
        }

        .player-image-container.selected {
            transform: scale(1.5);
            box-shadow: 0 0 12px gold, 0 0 22px orange, 0 0 8px rgba(0,0,0,0.3);
            z-index: 100; /* Bring selected to front */
        }

        .player-image-container.eliminated {
            opacity: 0.3;
        }

        .status-message {
            margin-top: 20px;
            font-weight: 700;
            color: #D32F2F;
            min-height: 1.5em;
            width: 100%;
            max-width: 550px; /* Match circle container width */
            text-align: center;
            font-size: 1.1em;
            padding: 10px;
            background-color: rgba(255,255,255,0.65);
            border-radius: 8px;
        }

        .player-image-container.hit-effect {
            animation: shakeAndFlashImg 0.4s ease-in-out;
        }
        @keyframes shakeAndFlashImg {
            0%, 100% { transform: translateX(0) scale(1.5); filter: brightness(1.2); }
            25% { transform: translateX(-7px) rotate(-6deg) scale(1.5); filter: brightness(0.7); } /* Increased movement */
            50% { transform: translateX(7px) rotate(6deg) scale(1.5); filter: brightness(1.6); } /* Increased movement */
            75% { transform: translateX(-5px) rotate(-4deg) scale(1.5); filter: brightness(0.7); }
        }

        .player-image-container.fly-out {
            animation: flyOutAnimation 1s forwards ease-in;
            transform-origin: center center;
        }
        @keyframes flyOutAnimation {
            0% { transform: rotateZ(0deg) scale(1.3); opacity: 1; }
            50% { transform: translate(calc(var(--flyout-x, 200px) / 2), calc(var(--flyout-y, -250px) - 75px)) rotateZ(720deg) scale(0.7); opacity: 0.8; }
            100% { transform: translate(var(--flyout-x, 200px), var(--flyout-y, -250px)) rotateZ(1440deg) scale(0.1); opacity: 0; }
        }

        .player-image-container.wiggle-error {
            animation: wiggleErrorAnimation 0.5s ease-in-out;
        }
        @keyframes wiggleErrorAnimation {
            0%, 100% { transform: translateX(0) scale(1); }
            20%, 60% { transform: translateX(-9px) rotate(-6deg) scale(1.1); } /* Increased movement */
            40%, 80% { transform: translateX(9px) rotate(6deg) scale(1.1); }
        }

        .giant-pistol {
            font-size: 7em; /* Increased size */
            position: absolute;
            left: -120px; /* Adjusted for size */
            top: 50%;
            transform: translateY(-50%) scaleX(-1);
            transform-origin: center center;
            visibility: hidden;
            z-index: 200;
            transition: transform 0.5s ease-out, left 0.5s ease-out, top 0.5s ease-out, opacity 0.3s;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .giant-pistol.visible { visibility: visible; }

        .bullet-emoji {
            font-size: 2.2em; /* Slightly larger */
            position: absolute;
            visibility: hidden;
            z-index: 190;
            color: orangeRed;
            text-shadow: 0 0 5px black;
            transition: transform 0.2s linear, opacity 0.1s linear;
        }
        .bullet-emoji.visible { visibility: visible; }

        .player-image-container.shivering {
            animation: shiverAnimationImg 0.08s infinite linear; /* Faster shiver */
            transform: scale(1.6) !important;
        }
        @keyframes shiverAnimationImg {
            0% { transform: translate(0px, 0px) rotate(-1.5deg) scale(1.6); } /* Increased effect */
            25% { transform: translate(-2.5px, 2.5px) rotate(0deg) scale(1.6); }
            50% { transform: translate(2.5px, -2.5px) rotate(1.5deg) scale(1.6); }
            75% { transform: translate(-2.5px, -2.5px) rotate(0deg) scale(1.6); }
            100% { transform: translate(2.5px, 2.5px) rotate(-1.5deg) scale(1.6); }
        }

        .smoke-puff {
            position: absolute;
            width: 25px; /* Larger puffs */
            height: 25px;
            background-color: rgba(128, 128, 128, 0.6);
            border-radius: 50%;
            opacity: 0.7;
            pointer-events: none;
            z-index: 180;
            animation: smokePuffAnim 0.8s ease-out forwards;
            transform-origin: center center;
        }
        @keyframes smokePuffAnim {
            0% { transform: scale(0.5); opacity: 0.7; }
            100% { transform: scale(2.8) translateY(-25px); opacity: 0; } /* More spread */
        }

        .speech-bubble {
            background: #fff; border-radius: 10px; padding: 10px 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); border: 2px solid #777;
            color: #333; min-width: 100px; max-width: 200px; text-align: center;
            z-index: 300; transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            transform: scale(0.8); opacity: 0;
        }
        .speech-bubble.visible { transform: scale(1); opacity: 1; visibility: visible !important; }
        .speech-bubble::after {
            content: ''; position: absolute; bottom: -10px; left: 50%;
            transform: translateX(-50%); width: 0; height: 0;
            border-left: 10px solid transparent; border-right: 10px solid transparent;
            border-top: 10px solid #777;
        }
        .speech-bubble.point-up::after {
            bottom: auto; top: -10px; border-top: none; border-bottom: 10px solid #777;
        }
        .speech-bubble p.speech-bubble-text { margin: 0; font-size: 0.9em; }

        .eliminated-player-placeholder {
            position: absolute;
            width: var(--player-diameter); /* Match player size */
            height: var(--player-diameter);/* Match player size */
            background-color: rgba(100, 100, 100, 0.25);
            border-radius: 50%;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--player-diameter) * 0.4); /* Scale skull with placeholder */
            color: rgba(50,50,50,0.6);
            transition: opacity 0.5s ease;
        }

        .circle-container.no-border { border: none; }

        .formula-display-panel {
            width: 100%; max-width: 500px; margin: 20px auto; padding: 20px;
            background-color: rgba(255, 255, 255, 0.88); border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15); text-align: left;
            font-family: 'Courier New', Courier, monospace; display: none;
            line-height: 1.6; font-size: 0.95em; color: #333;
        }
        .formula-display-panel h3 {
            font-family: 'Nunito', sans-serif; text-align: center; color: #2193b0;
            margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .formula-display-panel p { margin: 8px 0; display: flex; align-items: center; }
        .formula-display-panel .formula-step { padding: 5px; border-bottom: 1px dashed #eee; }
        .formula-display-panel .formula-step:last-child { border-bottom: none; }
        .formula-display-panel .formula-highlight { font-weight: bold; color: #ff6347; }
        .formula-display-panel img.formula-pic {
            width: 30px; height: 30px; border-radius: 50%; object-fit: cover;
            margin: 0 5px; vertical-align: middle; border: 1px solid #ccc;
        }
        #player_count_display_container {
            margin-top: 10px; font-weight: bold; color: #444;
        }

        @media (max-width: 960px) { /* Adjusted breakpoint */
            .game-layout {
                flex-direction: column;
                align-items: center;
            }
            .game-panel-left,
            .game-panel-right {
                max-width: 95%;
                width: 100%;
                align-items: center;
                margin-bottom: 20px;
            }
            .game-panel-left {
                max-width: 500px; /* Allow controls to be a bit wider */
            }
            .circle-container {
                width: 450px; /* Responsive size */
                height: 450px;
            }
            :root { --player-diameter: 60px; } /* Smaller players on smaller screens */
             .giant-pistol { font-size: 6em; }
        }

        @media (max-width: 600px) { /* Adjusted breakpoint */
            .container h1 { font-size: 2.8em; }
            .circle-container {
                width: 350px; /* Further responsive size */
                height: 350px;
            }
             :root { --player-diameter: 50px; }
            .game-panel-left { padding: 15px; }
            .controls button { font-size: 1em; }
             .giant-pistol { font-size: 5em; }
        }
         @media (max-width: 420px) {
            .circle-container {
                width: 300px;
                height: 300px;
            }
             :root { --player-diameter: 45px; }
             .giant-pistol { font-size: 4.5em; }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>图片约瑟夫环</h1>

        <div class="game-layout">
            <div class="game-panel game-panel-left">
                <div class="controls">
                    <div>
                        <label for="n_value">每数到第 N 个:</label>
                        <input type="number" id="n_value" value="3" min="1">
                    </div>
                    <div>
                        <span class="simulation-mode-label">模拟方式:</span>
                        <div class="simulation-mode-options">
                            <label><input type="radio" name="simulation_mode" value="array" checked> 数组模拟</label>
                            <label><input type="radio" name="simulation_mode" value="linkedlist"> 链表模拟</label>
                            <label><input type="radio" name="simulation_mode" value="formula"> 公式法</label>
                        </div>
                    </div>
                    <button id="start_button">开始游戏</button>
                    <div id="player_count_display_container">
                        当前玩家数: <span id="player_count_display">0</span>
                    </div>
                </div>

                <div class="game-info">
                    <p>轮次: <span id="round_count">0</span></p>
                    <p>当前 N 值: <span id="current_n_value">3</span></p>
                    <p>"幸运儿": <span id="selected_player_info">---</span></p>
                    <p>下次开始: <span id="next_start_player_info">---</span></p>
                </div>
            </div>

            <div class="game-panel game-panel-right">
                <div class="circle-container">
                    <!-- Player images will be added here by JavaScript -->
                </div>
                <div id="formula_display_panel" class="formula-display-panel">
                    <!-- Formula calculation steps will be shown here -->
                </div>

                <div class="status-message">
                    <p id="game_status_message"></p>
                </div>
            </div>
        </div>

        <div id="giant_pistol_emoji" class="giant-pistol">🔫</div>
        <div id="bullet_emoji" class="bullet-emoji">💥</div>

        <div id="speech_bubble_template" class="speech-bubble" style="visibility: hidden; position: absolute;">
            <p class="speech-bubble-text">Error!</p>
        </div>

    </div>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
    let players = [];
    let currentPlayerIndex = 0;
    let roundCount = 0;
    let gameNValue = 3;
    let gameStarted = false;
    let targetPlayerForSelection = null;
    let awaitingPlayerClick = false;
    let simulationMode = 'array';
    let nextPlayerId = 0;

    // Use a JS constant for player diameter, ensure it matches CSS var(--player-diameter) if dynamic changes needed
    // For simplicity, we'll read it from CSS or assume a default if CSS var isn't supported/parsed easily here.
    // Let's assume the CSS var sets it and we use a fallback.
    const getPlayerDiameter = () => {
        const diameterFromCSS = getComputedStyle(document.documentElement).getPropertyValue('--player-diameter');
        return parseInt(diameterFromCSS) || 65; // Fallback to 65px
    };


    const nValueInput = document.getElementById('n_value');
    const startButton = document.getElementById('start_button');
    const circleContainer = document.querySelector('.circle-container');
    const roundCountDisplay = document.getElementById('round_count');
    const currentNValueDisplay = document.getElementById('current_n_value');
    const selectedPlayerInfoDisplay = document.getElementById('selected_player_info');
    const gameStatusMessageDisplay = document.getElementById('game_status_message');
    const nextStartPlayerInfoDisplay = document.getElementById('next_start_player_info');
    const simulationModeRadios = document.querySelectorAll('input[name="simulation_mode"]');
    const playerCountDisplay = document.getElementById('player_count_display');
    const giantPistolElement = document.getElementById('giant_pistol_emoji');
    const bulletElement = document.getElementById('bullet_emoji');
    const speechBubbleTemplate = document.getElementById('speech_bubble_template');
    const formulaDisplayPanel = document.getElementById('formula_display_panel');
    let activeSpeechBubble = null;

    function createPlayerInfoHtml(player, textPrefix = '') {
        if (!player || !player.imageUrl) return `<span>${textPrefix} ---</span>`;
        const playerDisplayName = player.name ? player.name : `P-${player.originalIndex + 1}`;
        return `${textPrefix} <img src="${player.imageUrl}" class="info-pic" alt="${playerDisplayName}"> ${playerDisplayName}`;
    }
    
    function updatePlayerCount() {
        playerCountDisplay.textContent = players.length;
        const canStartInteractive = players.length >= 2;
        const canStartFormula = players.length >= 1;

        if (gameStarted) return; // Don't change button if game is in progress

        if (simulationMode === 'formula') {
            startButton.disabled = !canStartFormula;
        } else {
            startButton.disabled = !canStartInteractive;
        }
    }

    function calculateJosephusWinner(numPlayers, k) {
        if (numPlayers <= 0) return -1;
        if (k <= 0) k = 1;
        let survivorIndex = 0;
        for (let i = 1; i <= numPlayers; i++) {
            survivorIndex = (survivorIndex + k) % i;
        }
        return survivorIndex;
    }

    async function executeFormulaCalculation() {
        gameNValue = parseInt(nValueInput.value) || 3;
        currentNValueDisplay.textContent = gameNValue;
        const numPlayers = players.length;
        formulaDisplayPanel.innerHTML = '';

        if (numPlayers === 0) {
            gameStatusMessageDisplay.textContent = '请先粘贴图片添加玩家!';
            formulaDisplayPanel.innerHTML = '<p style="color:red;">没有玩家!</p>';
            startButton.disabled = true;
            return;
        }
        startButton.disabled = false;

        if (gameNValue <= 0) {
            gameStatusMessageDisplay.textContent = 'N值必须大于0!';
            formulaDisplayPanel.innerHTML = '<p style="color:red;">N值必须大于0!</p>';
            if(!nValueInput.classList.contains('wiggle-error')) {
                nValueInput.classList.add('wiggle-error');
                setTimeout(() => nValueInput.classList.remove('wiggle-error'), 500);
            }
            return;
        }

        let calculationHTML = `<h3>公式计算步骤 (N=${gameNValue})</h3>`;
        calculationHTML += `<p>总玩家数: ${numPlayers}</p>`;
        calculationHTML += `<p>公式: f(i, k) = (f(i-1, k) + k) % i</p>`;
        calculationHTML += `<p>其中 f(1, k) = 0 (0-indexed)</p><hr>`;

        let survivorIndex = 0;
        for (let i = 1; i <= numPlayers; i++) {
            const prevSurvivorIndex = survivorIndex;
            survivorIndex = (survivorIndex + gameNValue) % i;
            calculationHTML += `<div class="formula-step">f(${i}, ${gameNValue}) = (f(${i-1}, ${gameNValue}) + ${gameNValue}) % ${i} = (${prevSurvivorIndex} + ${gameNValue}) % ${i} = <span class="formula-highlight">${survivorIndex}</span></div>`;
        }
        
        const winnerPlayer = players[survivorIndex];

        if (winnerPlayer) {
            const winnerDisplayName = winnerPlayer.name ? winnerPlayer.name : `P-${winnerPlayer.originalIndex + 1}`;
            calculationHTML += `<hr><p>最终幸存者索引 (0-indexed): <span class="formula-highlight">${survivorIndex}</span></p>`;
            calculationHTML += `<p>对应玩家: <img src="${winnerPlayer.imageUrl}" class="formula-pic" alt="Winner"> <span class="formula-highlight">${winnerDisplayName}</span></p>`;
            formulaDisplayPanel.innerHTML = calculationHTML;

            gameStatusMessageDisplay.textContent = `公式计算结果: 胜利者是 ${winnerDisplayName}`;
            selectedPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(winnerPlayer);
            roundCountDisplay.textContent = "1";
            endGame(winnerPlayer, true);
        } else {
            formulaDisplayPanel.innerHTML = '<p style="color:red;">公式计算出错! (找不到玩家)</p>';
            gameStatusMessageDisplay.textContent = '公式计算出错!';
            startButton.disabled = false;
        }
    }

    function tick() {
        return new Promise(resolve => requestAnimationFrame(resolve));
    }

    function initializeGame() {
        gameNValue = parseInt(nValueInput.value) || 3;
        currentNValueDisplay.textContent = gameNValue;
        simulationMode = document.querySelector('input[name="simulation_mode"]:checked').value;

        players = [];
        nextPlayerId = 0;
        currentPlayerIndex = 0;
        roundCount = 0;
        updateRoundDisplay();
        selectedPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
        nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
        awaitingPlayerClick = false;
        targetPlayerForSelection = null;
        
        gameStarted = false; // Reset gameStarted flag

        giantPistolElement.classList.remove('visible');
        bulletElement.classList.remove('visible');
        if (activeSpeechBubble) { activeSpeechBubble.remove(); activeSpeechBubble = null; }
        clearPlaceholders();
        circleContainer.classList.remove('no-border');
        formulaDisplayPanel.style.display = 'none';
        circleContainer.style.display = 'flex'; // Changed from 'block' to 'flex' for consistency
        updatePlayerCount(); // This will set startButton.disabled based on player count and mode

        if (simulationMode === 'formula') {
            gameStatusMessageDisplay.textContent = '粘贴图片添加玩家, 然后点击 "计算获胜者"';
            startButton.textContent = '计算获胜者';
            circleContainer.style.display = 'none';
            formulaDisplayPanel.style.display = 'block';
            formulaDisplayPanel.innerHTML = '<h3>公式计算步骤</h3><p>请先添加玩家, 然后点击 "计算获胜者".</p>';
        } else {
            gameStatusMessageDisplay.textContent = '粘贴图片添加玩家, 设置N值和模式, 点击开始游戏!';
            startButton.textContent = '开始游戏';
        }
        renderPlayers();
        if (simulationMode === 'formula' || !gameStarted) {
            players.forEach(p => p.element?.classList.remove('next-start'));
            nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
        }
    }

    function clearPlaceholders() {
        const placeholders = circleContainer.querySelectorAll('.eliminated-player-placeholder');
        placeholders.forEach(p => p.remove());
    }

    function renderPlayers() {
        const PLAYER_DIAMETER = getPlayerDiameter();
        const existingPlayerElements = circleContainer.querySelectorAll('.player-image-container');
        existingPlayerElements.forEach(el => el.remove());
        
        if (simulationMode === 'array') {
            // Placeholders managed as before
        } else {
            clearPlaceholders();
        }

        // Radius for the center of the player images
        // (ContainerRadius - PlayerRadius - PaddingFromContainerBorder)
        const radius = (circleContainer.offsetWidth / 2) - (PLAYER_DIAMETER / 2) - 10; // 10px padding from border

        const activePlayers = players.filter(p => !p.isEliminated);
        
        let displayIndex = 0;
        players.forEach((player) => {
            let angle, x, y;

            if (simulationMode === 'array') {
                if (players.length === 0) return;
                angle = (player.originalIndex / players.length) * 2 * Math.PI - (Math.PI / 2);
                // Calculate center point for the player
                x = radius * Math.cos(angle) + (circleContainer.offsetWidth / 2);
                y = radius * Math.sin(angle) + (circleContainer.offsetHeight / 2);

                if (player.isEliminated) {
                    if (!circleContainer.querySelector(`.placeholder-id-${player.id}`)) {
                        const placeholderDiv = document.createElement('div');
                        placeholderDiv.classList.add('eliminated-player-placeholder');
                        placeholderDiv.classList.add(`placeholder-id-${player.id}`);
                        placeholderDiv.textContent = '💀';
                        placeholderDiv.style.left = `${x - PLAYER_DIAMETER / 2}px`;
                        placeholderDiv.style.top = `${y - PLAYER_DIAMETER / 2}px`;
                        circleContainer.appendChild(placeholderDiv);
                    }
                    player.element = null;
                    return;
                }
            } else { // linkedlist mode
                circleContainer.classList.remove('no-border');
                if (player.isEliminated) {
                    player.element = null;
                    return;
                }
                if (activePlayers.length === 0) return;
                angle = (displayIndex / activePlayers.length) * 2 * Math.PI - (Math.PI / 2);
                x = radius * Math.cos(angle) + (circleContainer.offsetWidth / 2);
                y = radius * Math.sin(angle) + (circleContainer.offsetHeight / 2);
                displayIndex++;
            }
            
            const playerDiv = document.createElement('div');
            playerDiv.classList.add('player-image-container');
            
            const img = document.createElement('img');
            img.src = player.imageUrl;
            img.alt = player.name || `Player ${player.id}`;
            playerDiv.appendChild(img);
            
            playerDiv.style.left = `${x - PLAYER_DIAMETER / 2}px`;
            playerDiv.style.top = `${y - PLAYER_DIAMETER / 2}px`;
            player.element = playerDiv;

            playerDiv.classList.remove('selected', 'hit-effect', 'fly-out', 'wiggle-error', 'shivering');

            if (awaitingPlayerClick && !player.isEliminated) {
                playerDiv.style.cursor = 'pointer';
                playerDiv.addEventListener('click', () => handlePlayerClick(player), { once: true });
            } else {
                playerDiv.style.cursor = 'default';
            }
            circleContainer.appendChild(playerDiv);
        });
        updateNextStartPlayerVisual();
    }
    
    function updateNextStartPlayerVisual() {
        players.forEach(p => p.element?.classList.remove('next-start'));
        if ((!gameStarted && simulationMode !== 'formula') || simulationMode === 'formula') {
            nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
            return;
        }

        const activePlayers = players.filter(p => !p.isEliminated);
        if (activePlayers.length === 0) {
            nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
            return;
        }
        
        const actualNextPlayer = activePlayers[currentPlayerIndex % activePlayers.length];
        if (actualNextPlayer && actualNextPlayer.element) {
            actualNextPlayer.element.classList.add('next-start');
            nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(actualNextPlayer, "下次从: ");
        } else {
            nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null, "下次从: ");
        }
    }

    function updateRoundDisplay() {
        roundCountDisplay.textContent = roundCount;
    }

    function startSelectionPhase() {
        if (!gameStarted || awaitingPlayerClick || giantPistolElement.classList.contains('visible')) return;

        gameNValue = parseInt(nValueInput.value) || 3;
        currentNValueDisplay.textContent = gameNValue;

        const activePlayers = players.filter(p => !p.isEliminated);
        if (activePlayers.length <= 1) {
            endGame(activePlayers.length > 0 ? activePlayers[0] : null);
            return;
        }

        roundCount++;
        updateRoundDisplay();
        
        activePlayers.forEach(p => p.element?.classList.remove('selected', 'wiggle-error', 'shivering'));
        
        const startingPlayerInActive = activePlayers[currentPlayerIndex % activePlayers.length];
        if (!startingPlayerInActive) {
            console.error("Error: No starting player found.");
            endGame(null); return;
        }

        let stepsToTake = gameNValue;
        let currentSearchIndexInActive = currentPlayerIndex % activePlayers.length;
        
        for (let i = 1; i < stepsToTake; i++) {
            currentSearchIndexInActive = (currentSearchIndexInActive + 1) % activePlayers.length;
        }
        targetPlayerForSelection = activePlayers[currentSearchIndexInActive];

        awaitingPlayerClick = true;
        selectedPlayerInfoDisplay.innerHTML = `从 ${createPlayerInfoHtml(startingPlayerInActive)} 开始数 ${gameNValue} 个.`;
        gameStatusMessageDisplay.textContent = '请点击你认为会被选中的玩家!';
        startButton.disabled = true;
        startButton.textContent = '等待选择...';
        renderPlayers(); 
        updateNextStartPlayerVisual(); // Ensure next start is highlighted after render
    }

    function showSpeechBubble(targetElement, message) {
        if (activeSpeechBubble) activeSpeechBubble.remove();
        activeSpeechBubble = speechBubbleTemplate.cloneNode(true);
        activeSpeechBubble.removeAttribute('id');
        activeSpeechBubble.querySelector('.speech-bubble-text').textContent = message;
        document.body.appendChild(activeSpeechBubble);
        const targetRect = targetElement.getBoundingClientRect();
        const bubbleRect = activeSpeechBubble.getBoundingClientRect();
        let top = targetRect.top - bubbleRect.height - 15;
        let left = targetRect.left + (targetRect.width / 2) - (bubbleRect.width / 2);
        if (left < 0) left = 5;
        if (left + bubbleRect.width > window.innerWidth) left = window.innerWidth - bubbleRect.width - 5;
        if (top < 0) {
            top = targetRect.bottom + 15;
            activeSpeechBubble.classList.add('point-up');
        } else {
            activeSpeechBubble.classList.remove('point-up');
        }
        activeSpeechBubble.style.top = `${top + window.scrollY}px`;
        activeSpeechBubble.style.left = `${left + window.scrollX}px`;
        activeSpeechBubble.style.visibility = 'visible';
        requestAnimationFrame(() => activeSpeechBubble.classList.add('visible'));
        setTimeout(() => {
            if (activeSpeechBubble) {
                activeSpeechBubble.classList.remove('visible');
                setTimeout(() => { if (activeSpeechBubble) activeSpeechBubble.remove(); activeSpeechBubble = null; }, 300);
            }
        }, 3000);
    }

    async function handlePlayerClick(clickedPlayer) {
        if (!awaitingPlayerClick || clickedPlayer.isEliminated || !clickedPlayer.element) return;

        if (clickedPlayer === targetPlayerForSelection) {
            awaitingPlayerClick = false;
            // startButton remains disabled as animation runs / next round starts automatically
            
            players.forEach(p => p.element?.classList.remove('selected', 'next-start'));
            clickedPlayer.element.classList.add('selected');

            await animateDetailedElimination(clickedPlayer);

            clickedPlayer.isEliminated = true;

            const activePlayers = players.filter(p => !p.isEliminated);
            if (activePlayers.length <= 1) {
                endGame(activePlayers.length > 0 ? activePlayers[0] : null);
                return;
            }

            let indexOfEliminatedInOriginalPlayersArray = players.findIndex(p => p.id === clickedPlayer.id);
            let nextActivePlayerFound = false;
            for (let i = 1; i <= players.length; i++) {
                const potentialNextOriginalIndex = (indexOfEliminatedInOriginalPlayersArray + i) % players.length;
                const potentialNextPlayer = players[potentialNextOriginalIndex];
                if (!potentialNextPlayer.isEliminated) {
                    currentPlayerIndex = activePlayers.indexOf(potentialNextPlayer);
                    if (currentPlayerIndex !== -1) {
                        nextActivePlayerFound = true;
                        break;
                    }
                }
            }
            if (!nextActivePlayerFound && activePlayers.length > 0) {
                currentPlayerIndex = 0;
            }

            targetPlayerForSelection = null;
            selectedPlayerInfoDisplay.innerHTML = `${createPlayerInfoHtml(clickedPlayer)} 已出局!`;
            gameStatusMessageDisplay.textContent = '准备下一轮选择...';
            
            if (simulationMode === 'linkedlist') renderPlayers(); 
            updateNextStartPlayerVisual();

            setTimeout(() => {
                if(gameStarted) startSelectionPhase();
            }, simulationMode === 'linkedlist' ? 500 : 1500);

        } else {
            showSpeechBubble(clickedPlayer.element, `点错了! 目标不是我!`);
            gameStatusMessageDisplay.textContent = '请从指定的起始玩家再数一次!';
            if (clickedPlayer.element) {
                clickedPlayer.element.classList.add('wiggle-error');
                setTimeout(() => {
                    clickedPlayer.element?.classList.remove('wiggle-error');
                }, 2800);
            }
        }
    }

    async function animateDetailedElimination(player) {
        const victimElement = player.element;
        if (!victimElement) return;
        const PLAYER_DIAMETER = getPlayerDiameter();
        const victimOriginalStyle = { left: victimElement.style.left, top: victimElement.style.top };

        // startButton is already disabled
        gameStatusMessageDisplay.textContent = '正在淘汰中...';
        selectedPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
        await tick();

        const playerRect = victimElement.getBoundingClientRect();
        let pistolActualWidth = giantPistolElement.offsetWidth || 96; // Fallback
        const targetPistolVisualRight_viewport = playerRect.left - (PLAYER_DIAMETER * 0.4); // Move pistol closer
        const targetPistolStyleLeft_viewport = targetPistolVisualRight_viewport - pistolActualWidth;
        const targetPistolCenterY_viewport = playerRect.top + playerRect.height / 2;

        giantPistolElement.style.top = `${targetPistolCenterY_viewport}px`;
        giantPistolElement.style.left = `${targetPistolStyleLeft_viewport}px`;
        giantPistolElement.style.transform = 'translateY(-50%) scaleX(-1) rotate(0deg)';
        giantPistolElement.classList.add('visible');
        victimElement.classList.add('shivering', 'selected'); // 'selected' ensures z-index
        await new Promise(resolve => setTimeout(resolve, 1000));
        victimElement.classList.remove('shivering');

        giantPistolElement.style.transform = 'translateY(-50%) scaleX(-1) translateX(20px) rotate(5deg)';
        await new Promise(resolve => setTimeout(resolve, 120));
        giantPistolElement.style.transform = 'translateY(-50%) scaleX(-1) translateX(0px) rotate(0deg)';
        
        bulletElement.style.top = `${playerRect.top + playerRect.height / 2 - bulletElement.offsetHeight / 2}px`;
        bulletElement.style.left = `${playerRect.left - bulletElement.offsetWidth - 5}px`; // Start left of player
        bulletElement.classList.add('visible');
        
        const victimTargetCenterX_viewport = playerRect.left + playerRect.width / 2;
        const victimTargetCenterY_viewport = playerRect.top + playerRect.height / 2;
        const bulletCurrentLeft_viewport = parseFloat(bulletElement.style.left);
        const bulletCurrentTop_viewport = parseFloat(bulletElement.style.top);
        const translateX = victimTargetCenterX_viewport - bulletCurrentLeft_viewport - (bulletElement.offsetWidth / 2);
        const translateY = victimTargetCenterY_viewport - bulletCurrentTop_viewport - (bulletElement.offsetHeight / 2);
        bulletElement.style.transform = `translate(${translateX}px, ${translateY}px)`;
        await new Promise(resolve => setTimeout(resolve, 200));
        bulletElement.classList.remove('visible');
        bulletElement.style.transform = 'translate(0,0)';

        victimElement.classList.add('hit-effect');
        await new Promise(resolve => setTimeout(resolve, 400));
        victimElement.classList.remove('hit-effect');

        if (simulationMode === 'linkedlist') {
            const flyX = (Math.random() - 0.5) * 2 * 250;
            const flyY = -200 - Math.random() * 150;
            victimElement.style.setProperty('--flyout-x', `${flyX}px`);
            victimElement.style.setProperty('--flyout-y', `${flyY}px`);
            victimElement.classList.add('fly-out');

            const smokeInterval = 80; const flyOutDuration = 1000; let smokeTimer = 0;
            const smokePuffParent = circleContainer;
            const smokeIntervalId = setInterval(() => {
                if (smokeTimer >= flyOutDuration) { clearInterval(smokeIntervalId); return; }
                const puff = document.createElement('div'); puff.classList.add('smoke-puff');
                const victimRectNow = victimElement.getBoundingClientRect();
                const parentRect = smokePuffParent.getBoundingClientRect();
                let puffLeft = victimRectNow.left + (victimRectNow.width / 2) - 10 - parentRect.left;
                let puffTop = victimRectNow.top + (victimRectNow.height / 2) - 10 - parentRect.top;
                puff.style.left = `${puffLeft}px`; puff.style.top = `${puffTop}px`;
                smokePuffParent.appendChild(puff);
                setTimeout(() => { puff.remove(); }, 800);
                smokeTimer += smokeInterval;
            }, smokeInterval);
            
            await new Promise(resolve => setTimeout(resolve, flyOutDuration));
            victimElement.style.visibility = 'hidden'; victimElement.remove(); player.element = null;
        } else { // Array mode
            await new Promise(resolve => setTimeout(resolve, 100));
            victimElement.style.visibility = 'hidden'; victimElement.remove(); player.element = null;
        }

        giantPistolElement.classList.remove('visible');
        giantPistolElement.style.left = '-150px';
        giantPistolElement.style.transform = 'translateY(-50%) scaleX(-1) rotate(0deg)';

        if (simulationMode === 'array') {
            if (!circleContainer.querySelector(`.placeholder-id-${player.id}`)) {
                const placeholderDiv = document.createElement('div');
                placeholderDiv.classList.add('eliminated-player-placeholder');
                placeholderDiv.classList.add(`placeholder-id-${player.id}`);
                placeholderDiv.textContent = '💀';
                placeholderDiv.style.left = victimOriginalStyle.left;
                placeholderDiv.style.top = victimOriginalStyle.top;
                circleContainer.appendChild(placeholderDiv);
            }
        }
    }

    function endGame(winner, isFormulaMode = false) {
        awaitingPlayerClick = false;
        giantPistolElement.classList.remove('visible');
        bulletElement.classList.remove('visible');
        
        if (!isFormulaMode) clearPlaceholders();

        if (winner) {
            const winnerDisplayName = winner.name ? winner.name : `P-${winner.originalIndex + 1}`;
            gameStatusMessageDisplay.textContent = `游戏结束! 胜利者是: ${winnerDisplayName}`;
            selectedPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(winner);
            nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(winner);

            players.forEach(p => p.isEliminated = (p.id !== winner.id));
            renderPlayers();

            winner.element?.classList.add('selected');
            winner.element?.classList.remove('next-start');
        } else {
            gameStatusMessageDisplay.textContent = '游戏结束! 没有胜利者。';
            if (!isFormulaMode) renderPlayers();
            selectedPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
            nextStartPlayerInfoDisplay.innerHTML = createPlayerInfoHtml(null);
        }

        startButton.disabled = false;
        if (isFormulaMode) {
            startButton.textContent = '重新计算';
        } else {
            startButton.textContent = '重新开始';
        }
        gameStarted = false;
        targetPlayerForSelection = null;
        updatePlayerCount();
    }

    startButton.addEventListener('click', () => {
        simulationMode = document.querySelector('input[name="simulation_mode"]:checked').value;

        if (simulationMode === 'formula') {
            if (players.length < 1) {
                gameStatusMessageDisplay.textContent = "公式法至少需要1名玩家!";
                executeFormulaCalculation(); // Will show error via its own checks
                return;
            }
            executeFormulaCalculation();
        } else { // Array or LinkedList (interactive modes)
            if (!gameStarted) {
                if (players.length < 2) {
                    gameStatusMessageDisplay.textContent = "至少需要2名玩家才能开始互动游戏!";
                    return;
                }
                gameStarted = true;
                // Button will be handled by startSelectionPhase
                gameStatusMessageDisplay.textContent = "游戏开始! 正在进行第一轮选择...";
                updateNextStartPlayerVisual(); // Show who will start first
                startSelectionPhase(); // Directly start the first selection phase
            } else {
                // This case (gameStarted but not awaiting click) implies a manual "Next Round" button.
                // Currently, rounds flow automatically after a click.
                // If game logic changes to pause between rounds, this is where "Next Round" would be handled.
                // For now, this might not be hit often if startButton is disabled during rounds.
                // However, if startSelectionPhase was interrupted or button re-enabled, this allows restart.
                if (!awaitingPlayerClick && !giantPistolElement.classList.contains('visible')) {
                    startSelectionPhase();
                }
            }
        }
    });

    nValueInput.addEventListener('change', () => {
        const newNValue = parseInt(nValueInput.value);
        if (newNValue <= 0) {
            gameStatusMessageDisplay.textContent = "N值必须大于0!";
            nValueInput.value = gameNValue; // Revert
            if(!nValueInput.classList.contains('wiggle-error')) {
                nValueInput.classList.add('wiggle-error');
                setTimeout(() => nValueInput.classList.remove('wiggle-error'), 500);
            }
            return;
        }
        gameNValue = newNValue;
        currentNValueDisplay.textContent = gameNValue;
        // simulationMode is already known

        if (simulationMode === 'formula') {
            gameStatusMessageDisplay.textContent = `N值已更新为 ${gameNValue}. 点击 "计算获胜者".`;
        } else {
            if (!gameStarted) {
                gameStatusMessageDisplay.textContent = `N值已更新为 ${gameNValue}. 点击 "开始游戏".`;
            } else if (awaitingPlayerClick) {
                gameStatusMessageDisplay.textContent = `N值将在下次选择时更新为 ${gameNValue}.`;
            } else { // Game started, not awaiting click (i.e., between rounds or ready for next)
                gameStatusMessageDisplay.textContent = `N值已更新为 ${gameNValue}. 点击按钮开始选择。`;
            }
        }
    });
    
    simulationModeRadios.forEach(radio => {
        radio.addEventListener('change', (event) => {
            initializeGame();
        });
    });

    document.body.addEventListener('paste', (event) => {
        if (gameStarted && simulationMode !== 'formula') {
            showSpeechBubble(startButton, "游戏进行中, 不能添加新玩家!");
            return;
        }
        const items = (event.clipboardData || event.originalEvent.clipboardData).items;
        let imageFound = false;
        for (let index in items) {
            const item = items[index];
            if (item.kind === 'file' && item.type.startsWith('image/')) {
                imageFound = true;
                const file = item.getAsFile();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const newPlayer = {
                        id: nextPlayerId++,
                        imageUrl: e.target.result,
                        element: null,
                        isEliminated: false,
                        originalIndex: players.length, // Assign before pushing
                        name: `玩家${players.length + 1}` // Simple default name
                    };
                    players.push(newPlayer);
                    renderPlayers();
                    updatePlayerCount();
                    gameStatusMessageDisplay.textContent = `${newPlayer.name} 已添加! 总共 ${players.length} 名玩家.`;
                    
                    if (!gameStarted && simulationMode !== 'formula' && players.length > 0) {
                        updateNextStartPlayerVisual();
                    }
                };
                reader.readAsDataURL(file);
                break; // Process first image found
            }
        }
        if (!imageFound) {
            gameStatusMessageDisplay.textContent = "粘贴的内容不是图片, 请粘贴图片!";
        }
    });

    initializeGame();

    window.addEventListener('resize', () => {
        // Re-render on resize only if players exist and game is in a visual state
        if (players.length > 0 && (gameStarted || simulationMode === 'array' || simulationMode === 'linkedlist') ) {
             renderPlayers();
        }
    });
});
    </script>
</body>
</html>
